#include <Arduino.h>

namespace SLIP_Constants {
const static uint8_t END = 0300;
const static uint8_t ESC = 0333;
const static uint8_t ESC_END = 0334;
const static uint8_t ESC_ESC = 0335;
} // namespace SLIP_Constants

/// Parses SLIP packets: https://datatracker.ietf.org/doc/html/rfc1055
class SLIPParser {
  public:
    template <class Callback>
    size_t parse(uint8_t c, Callback callback);

    void reset() {
        size = 0;
        escape = false;
    }

  private:
    size_t size = 0;
    bool escape = false;
};

template <class Callback>
size_t SLIPParser::parse(uint8_t c, Callback callback) {
    using namespace SLIP_Constants;
    /*
     * handle bytestuffing if necessary
     */
    switch (c) {
        /*
         * if it's an END character then we're done with
         * the packet
         */
        case END: {
            /* 
             * a minor optimization: if there is no
             * data in the packet, ignore it. This is
             * meant to avoid bothering IP with all
             * the empty packets generated by the
             * duplicate END characters which are in
             * turn sent to try to detect line noise.
             */
            auto packetLen = size;
            reset();
            if (packetLen) return packetLen;
        } break;

        /*
         * if it's the same code as an ESC character, wait
         * and get another character and then figure out
         * what to store in the packet based on that.
         */
        case ESC: {
            escape = true;
        } break;

        /*
         * here we fall into the default handler and let
         * it store the character for us
         */
        default: {
            if (escape) {
                /*
                 * if "c" is not one of these two, then we
                 * have a protocol violation.  The best bet
                 * seems to be to leave the byte alone and
                 * just stuff it into the packet
                 */
                switch (c) {
                    case ESC_END: c = END; break;
                    case ESC_ESC: c = ESC; break;
                    default: break; // LCOV_EXCL_LINE (protocol violation)
                }
                escape = false;
            }
            callback(c, size);
            ++size;
        }
    }
    return 0;
}

/// Sends SLIP packets: https://datatracker.ietf.org/doc/html/rfc1055
class SLIPSender {
  public:
    SLIPSender(Stream &stream) : stream(stream) {}

    size_t beginPacket() { return stream.write(SLIP_Constants::END); }
    size_t endPacket() { return stream.write(SLIP_Constants::END); }

    size_t write(const uint8_t *data, size_t len);
    size_t writePacket(const uint8_t *data, size_t len) {
        size_t sent = 0;
        sent += beginPacket();
        sent += write(data, len);
        sent += endPacket();
        return sent;
    }

  private:
    Stream &stream;
};

inline size_t SLIPSender::write(const uint8_t *data, size_t len) {
    // https://datatracker.ietf.org/doc/html/rfc1055
    using namespace SLIP_Constants;
    size_t sent = 0;
    /* 
     * for each byte in the packet, send the appropriate character
     * sequence
     */
    while (len--) {
        switch (*data) {
            /*
             * if it's the same code as an END character, we send a
             * special two character code so as not to make the
             * receiver think we sent an END
             */
            case END:
                sent += stream.write(ESC);
                sent += stream.write(ESC_END);
                break;

            /*
             * if it's the same code as an ESC character,
             * we send a special two character code so as not
             * to make the receiver think we sent an ESC
             */
            case ESC:
                sent += stream.write(ESC);
                sent += stream.write(ESC_ESC);
                break;

            /*
             * otherwise, we just send the character
             */
            default: sent += stream.write(*data);
        }
        data++;
    }
    return sent;
}